#ifndef __TASK_TELLER_SERVICE    // header files should include guards
#define __TASK_TELLER_SERVICE

#include "cmsis_os.h"
#include "string.h"
#include "rng.h"

#include "Customer.h"
#include "Teller.h"
#include "Break.h"

typedef struct {
	// Generated by FreeRTOS, saved for later use (task synchronization, etc.)
  TaskHandle_t handle; 
  char task_name[16];
	int tellerID;
	
	// A pointer to main's simulation clock. How many seconds has passed since 9am (program beginning). 
	uint32_t* SimulationClockPtr;
	
	// A pointer to the teller that this task is representing
	Teller* teller;
	
	// A pointer to the queue of all customers in the queue
	QueueHandle_t* CustomerQueuePtr;
	
} TELLERSERVICE_PARAMS_t;
	

extern TELLERSERVICE_PARAMS_t teller_service_params[NUMBER_OF_TELLERS]; // defined here, allocated in led_task.c

void teller_service_task(void *parameters);
void teller_service_task_init(char *teller_service_task_name,
																int id,
																uint32_t* simulation_clock_ptr,
																Teller* my_teller,
																QueueHandle_t* customer_queue_ptr
);


/*
	Try to remove a customer from the customer queue ptr.
	If successfully (if there was a customer in the queue),
		add the customer to the teller's list of serviced custemers,
		and set that customer service start time to now (using the simulation clock ptr)
		and set the service end time to random value 30s to 8 minutes later.
		Set Teller's status to Busy.
	If not customer, do nothing.
*/																
void TakeCustomerFromQueue(int tellerID);


/*
	If the teller is busy, checks the current customer that the 
		teller is servicing. If the customer's service end time has passed,
		finish servicing that customer.

 */																
uint8_t IsCurrentCustomerServiced(int tellerID);																


/*
		If the teller can go on break, go to OnBreak.
		If not, go to Idle. 
*/
void EndCurrentCustomer(int tellerID);
			
/*
	Checks if the teller is able to go on break. 
  Teller can go on break if break start time has elapsed.
		Returns 1 if so, 0 if not
*/																
uint8_t CanGoOnBreak(int tellerID);


/*
	Set the Teller's status to OnBreak.
	Set the current break's end time to random time 1-4 minutes later.
	Add that break to the list of breaks.
*/
void StartBreak(int tellerID);


/*
	Checks if current break's end time has passed. If so, return 1.
		If not, return 0.
*/
uint8_t IsCurrentBreakOver(int tellerID);


/*
	Set the Teller's status back to Idle.
	Creates (schedules) the next break, and 
	  sets its start time to 30-60 minutes later.
 */
void EndBreak(int tellerID);
									
															
#endif

